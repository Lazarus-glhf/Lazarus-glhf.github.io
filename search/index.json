[{"content":"What do you need 搭建一个 Java Edition Minecraft 服务器所需的东西并不多:\n一台安装了操作系统并能够运行的电脑 Java 环境 MC 服务器资源 (Server Core) 一个良好的网络环境 * Tmux * FRP * 本教程使用的是 ubuntu 22.04 LTS 系统。下面让我们逐步进行。\nJava 环境 执行下列指令:\n1 2 3 4 5 6 7 8 9 sudo apt-get update sudo apt-get upgrade sudo apt install openjdk-17-jdk # 安装 jre sudo apt install openjdk-17-jre # 卸载 sudo apt remove openjdk-17-jre openjdk-17-jdk --purge 执行 java --version 验证安装是否成功\nMineCraft 服务器配置 服务器下载 MC 服务器种类繁多，这里以 Fabric Minecraft Server Launcher 为例。\nFabric is a lightweight, experimental modding toolchain for Minecraft.\n下载服务器资产非常简单，访问 Download Minecraft Server Launcher 界面:\n选择 Mincraft 版本，会自动生成资源下载链接，这里以 JE 1.20.1 为例。我们复制 Fabric 下载界面提供的下载指令 curl -OJ https://meta.fabricmc.net/v2/versions/loader/1.20.1/0.14.21/0.11.2/server/jar 至 linux 终端并运行。 会获得一个服务器的 jar 包。接着我们在服务器所在文件夹创建一个服务器启动脚本 vim run.sh, 将 Fabric 下载界面提供的启动命令 java -Xmx2G -jar fabric-server-mc.1.20.1-loader.0.14.21-launcher.0.11.2.jar nogui 输入，保存并退出。 列举一些 run.sh 可能用到的参数\n1. -Xmx?G ? 为服务器最多可用内存\n2. -Xms?G ? 为服务器最小占用内存\n3. nogui 不启用服务器 GUI\n4. -jar 后面为 Server Launcher 的名字，如果强迫症看着默认名字难受修改了的话，启动脚本需要修改\n随后我们别忘了给运行脚本执行权限，chomod +x run.sh。此时我们可以直接运行脚本了 ./run.sh，启动器会自动下载服务器核心资源，并生成需要的资产。 第一次运行会失败，并且给出下列提示: 这里我们需要去修改刚刚生成的 eula 用户许可文件。ls 查看本地文件发现有一个 eula.txt, 我们 vim eula.txt 去修改它。 我们将最后一行的 eula=false 改为 eula=true 即可，保存并退出。\n此时已经可以连接服务器愉快地玩耍了，但在此之前，我们可能还需要修改一些服务器的配置项。让我们输入 stop 终止服务器运行。我们查看服务器目录下的文件，发现有一个 server.properties 文件，这个就是服务器的配置文件，里面有着非常多的配置项。 关于具体选项的作用，可以查看 Minecraft Wiki 了解更多: Server.properties，这里主要提及几个比较重要的配置项：\n1 2 3 4 5 - online-mode=true #重要！当值为 true 时只有拥有 MC JE 正版的账户才能够进入服务器，并且可以使用诸如官方皮肤，披风等物品。此项一般也被称为正版验证。当值为 false 时关闭正版验证。 - server-port=25565 # 重要！服务器监听端口！ - query.port=25565 # 重要！服务器查询端口！ - difficulty=easy # 难度，关系到游戏的某些特性 - level-seed= #服务器种子，默认随机。 完成配置文件修改后我们再次运行 run.sh，如果显示以下的画面，恭喜你，服务器成功运行了！ Tmux 当我们在服务器运行时把终端的黑框框关掉时(包括 ssh 的终端)，那么服务器也会被直接关闭。显然我们不可能一直开着这个黑框框在电脑上，所以我们需要一些小工具，比如 Tmux。\n速通 Tmux 执行 sudo apt-get install tmux 安装 tmux。 新建会话 tmux new -s \u0026lt;session-name\u0026gt;。使用 tmux ls 浏览会话列表。 退出会话 tmux detach 或者 ctrl + b 接入会话 tmux a -t \u0026lt;session-name\u0026gt;，tmux a 默认接入上次打开的会话 结束会话 tmux kill-session -t \u0026lt;session-name\u0026gt; Tmux 在搭建服务器时的应用 tmux new -s MCServer 创建一个会话。 在会话内执行 run.sh 服务器启动脚本。 ctrl + b + d 退出会话，此时即使关闭终端服务器也不会停止运行。 Frp Frp 是什么？\nfrp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。\n关于 Frp 的更多内容，可以查阅官方文档与 Github 仓库。\n接下来示范如何将本地运行的 MC 服务器通过 Frp 反向代理到公网上。当然首先你需要一台拥有公网 ip 的电脑/服务器/VPS/路由器。\n安装 Frp。 访问 github 的 Releases，获取所需版本的下载链接。 在 Server (公网)和 Client (内网)上分别执行 wget https://github.com/fatedier/frp/releases/download/v0.51.1/frp_0.51.1_linux_amd64.tar.gz 指令下载预编译好的文件。 tar -zxvf frp.tar.gz 解压文件，可以获得如下文件： 配置 Frp 配置服务端(公网)文件 frps.ini，默认状态下 frps.ini 的内容是这样的。设置了 frp 服务器用户接收客户端连接的端口为默认的 7000。这里我们要记住端口，以及公网的 ip 地址。 配置客户端(局域网)文件 frpc.ini。默认状态下 frpc.ini 的内容是这样的: 1 2 3 4 5 6 7 8 9 10 11 12 # 必要！ [common] server_addr = 127.0.0.1 # 服务器的地址，这里要修改成你的公网服务器 IP server_port = 7000 # 服务器接收客户端连接的端口 # 一个名为 ssh 的配置项 # frp 会将请求服务器 6000 端口的流量转发到内网机器的 22 端口。 [ssh] type = tcp # 连接方式 local_ip = 127.0.0.1 # 本地地址 local_port = 22 # 需要转发的端口 remote_port = 6000 # 服务器监听端口 我们参考这份样例，先将 frpc.ini 中服务器的地址和接收端口改成自己的，然后在文件后面添加一个 MC 服务器需要使用的配置项:\n1 2 3 4 5 [MCServer] type = tcp # MCJE 使用 tcp 协议 local_ip = 127.0.0.1 # 本地地址 local_port = 25565 # MC 服务器监听和查询的地址，在 server.properties 中设定 remote_port = 25565 # 服务器监听端口 在公网服务器上开放需要使用到的端口，如 7000, 25565. 运行 Frp 反向代理 首先在服务器上执行 tmux new -s frps 创建一个 tmux 会话 然后在 frp 目录下执行 ./frps -c frps.ini 开启 frp 服务端后 ctrl + b + d 退出 tmux 会话。 在客户端上执行 tmux new -s frpc 创建一个 tmux 会话 在 frp 目录下执行 ./frpc -c frpc.ini 开启 frp 客户端后 ctrl + b + d 退出 tmux 会话。 此时如果服务端和客户端都没有错误信息，那说明反向代理搭建成功，可以通过公网访问内网 MC 服务器了。\n","date":"2023-07-22T00:00:00Z","image":"https://cdn.jsdelivr.net/gh/Lazarus-glhf/ImageStorage@main/Blog/tinify.png","permalink":"https://example.com/p/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA-mc-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8C%87%E5%8C%97/","title":"搭建个人 MC 服务器指北"},{"content":"1. 创建一个 Module，修改 Build.cs 和 .cpp 文件如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 .Build.cs using UnrealBuildTool; public class UnLuaTestEditor : ModuleRules { public UnLuaTestEditor(ReadOnlyTargetRules Target) : base(Target) { PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; // ComponentViz needed for the objects we\u0026#39;re visualizing PublicDependencyModuleNames.AddRange(new string[] { \u0026#34;Core\u0026#34;, \u0026#34;Engine\u0026#34;, \u0026#34;CoreUObject\u0026#34;, \u0026#34;UnluaTest\u0026#34; }); // Needed for our editor logic // 这里加入 UnrealEd 模块 PrivateDependencyModuleNames.AddRange(new string[] { \u0026#34;UnrealEd\u0026#34; });\t} } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026#34;UnLuaTestEditor.h\u0026#34; #include \u0026#34;UnrealEd.h\u0026#34; #include \u0026#34;LineVisualizer.h\u0026#34; #include \u0026#34;UnLuaTest/LineDraw.h\u0026#34; // Actually registers the module IMPLEMENT_GAME_MODULE(FUnLuaTestEditorModule, UnLuaTestEditor); void FUnLuaTestEditorModule::StartupModule() { UE_LOG(LogTemp, Warning, TEXT(\u0026#34;StartupModule\u0026#34;)); if (GUnrealEd) { UE_LOG(LogTemp, Warning, TEXT(\u0026#34;OnRegeister\u0026#34;)); TSharedPtr\u0026lt;FComponentVisualizer\u0026gt; Viz = MakeShareable(new LineVisualizer());\t// ULineDraw 为 自定义 ActorComponent, 这里对其注册 ComponentVisualizer GUnrealEd-\u0026gt;RegisterComponentVisualizer(ULineDraw::StaticClass()-\u0026gt;GetFName(), Viz); Viz-\u0026gt;OnRegister(); } else { UE_LOG(LogTemp, Warning, TEXT(\u0026#34;Regeister failed\u0026#34;)); } } void FUnLuaTestEditorModule::ShutdownModule() { if (GUnrealEd) { GUnrealEd-\u0026gt;UnregisterComponentVisualizer(ULineDraw::StaticClass()-\u0026gt;GetFName()); } } 2. ActorComponent 在编辑器默认 Module 下创建一 ActorComponent, ActorComponent 内主要存储画线所需要的信息，如点的位置，以及一些增加易用性的函数等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 .h // Fill out your copyright notice in the Description page of Project Settings. #pragma once #include \u0026#34;CoreMinimal.h\u0026#34; #include \u0026#34;PointActor.h\u0026#34; #include \u0026#34;Components/ActorComponent.h\u0026#34; #include \u0026#34;Curves/CurveVector.h\u0026#34; #include \u0026#34;LineDraw.generated.h\u0026#34; UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) ) class UNLUATEST_API ULineDraw : public UActorComponent { GENERATED_BODY() public:\t// Sets default values for this component\u0026#39;s properties ULineDraw(); protected: // Called when the game starts virtual void BeginPlay() override; public:\t// Called every frame virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override; /** Spawn Actor 的种类 */ UPROPERTY() TSubclassOf\u0026lt;APointActor\u0026gt; ActorToSpawn; /** 点的集合 */ UPROPERTY(EditAnywhere, BlueprintReadWrite) TArray\u0026lt;APointActor*\u0026gt; PointActors; /** 画线信息来源的 Curve, 增加的点的值最终也是更新到 Curve 上 */ UPROPERTY(EditAnywhere) UCurveVector* Points; /** 是否以 Component Owner 的坐标为起点 */ UPROPERTY(EditAnywhere) bool bDrawFromActor; /** 添加一个点 */ UFUNCTION(CallInEditor, Category=\u0026#34;Custom Point\u0026#34;) void AddPoints(); /** 销毁所有的点，重置 Curve 数据 */ UFUNCTION(CallInEditor, Category=\u0026#34;Custom Point\u0026#34;) void ClearAllPoints(); private: /**AddPoint() 生成 Point 对应 Curve 上的默认 Key 值 * 每次调用 +2 */ float PointDefaultTime = 0; }; //////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////// .cpp // Fill out your copyright notice in the Description page of Project Settings. #include \u0026#34;LineDraw.h\u0026#34; #include \u0026#34;GetMeshSizeInterface.h\u0026#34; // Sets default values for this component\u0026#39;s properties ULineDraw::ULineDraw() { // Set this component to be initialized when the game starts, and to be ticked every frame. You can turn these features // off to improve performance if you don\u0026#39;t need them. PrimaryComponentTick.bCanEverTick = true; bDrawFromActor = true; // ... } // Called when the game starts void ULineDraw::BeginPlay() { Super::BeginPlay(); // ... } // Called every frame void ULineDraw::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) { Super::TickComponent(DeltaTime, TickType, ThisTickFunction); // ... } void ULineDraw::AddPoints() { if (ActorToSpawn) { UWorld* MyWorld = GetWorld(); if (MyWorld) { APointActor* Point = MyWorld-\u0026gt;SpawnActor\u0026lt;APointActor\u0026gt;(ActorToSpawn, this-\u0026gt;GetOwner()-\u0026gt;GetActorLocation(), FRotator(0.f)); PointActors.Add(Point); Point-\u0026gt;AttachToActor(this-\u0026gt;GetOwner(), FAttachmentTransformRules::KeepWorldTransform); Point-\u0026gt;Time = PointDefaultTime; PointDefaultTime += 2; } } } void ULineDraw::ClearAllPoints() { for (APointActor* point : PointActors) { point-\u0026gt;Destroy(); } PointActors.Reset(); Points-\u0026gt;ResetCurve(); } 这里因为功能需求，我自己实现了个类似于 SplineComponent 的功能，可以在编辑器内设置线上的点。这里直接用一个自定义的 Actor : \u0026ldquo;APointActor\u0026rdquo;, 作为点，如果直接 Spawn 默认的 Actor 的话生成的 Actor 是不带 SceneComponent 的，也就是没有 Transform 属性，毕竟 UE Actor 的属性什么的都是通过挂载 Component 实现的，隔壁 Unity 好歹出生自带 Transform, UE 是真的啥也不带\n3. FComponentVisualizer 终于到了实现画线的部分，这里在自定义的 Module 下新建一空的 C++ 类， 然后让其继承自 FComponentVisualizer\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Fill out your copyright notice in the Description page of Project Settings. #pragma once #include \u0026#34;CoreMinimal.h\u0026#34; #include \u0026#34;ComponentVisualizer.h\u0026#34; /** * */ class UNLUATESTEDITOR_API LineVisualizer : public FComponentVisualizer { virtual void DrawVisualization(const UActorComponent* Component, const FSceneView* View, FPrimitiveDrawInterface* PDI) override; }; 只需要重写 DrawVisualization() 这一个函数就可以了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // Fill out your copyright notice in the Description page of Project Settings. #include \u0026#34;LineVisualizer.h\u0026#34; #include \u0026#34;SceneManagement.h\u0026#34; #include \u0026#34;UnLuaTest/LineDraw.h\u0026#34; void LineVisualizer::DrawVisualization(const UActorComponent* Component, const FSceneView* View, FPrimitiveDrawInterface* PDI) { // UE_LOG(LogTemp, Warning, TEXT(\u0026#34;Drawing\u0026#34;)); const ULineDraw* LineDrawer = Cast\u0026lt;const ULineDraw\u0026gt;(Component); // 获取组件所在 Actor 的坐标 FVector ActorLocation= LineDrawer-\u0026gt;GetOwner()-\u0026gt;GetTargetLocation(); if (LineDrawer-\u0026gt;Points != nullptr) { float Time = 0; float MaxTime; UCurveVector* Curve = LineDrawer-\u0026gt;Points; // 将 PointActor 点的信息写入到 Curve 里面 for (int i = 0; i \u0026lt; LineDrawer-\u0026gt;PointActors.Num(); i++) { APointActor* Point = LineDrawer-\u0026gt;PointActors[i]; FVector Val = Point-\u0026gt;GetActorLocation() - LineDrawer-\u0026gt;GetOwner()-\u0026gt; GetActorLocation(); FKeyHandle Key = Curve-\u0026gt;FloatCurves[0].UpdateOrAddKey(Point-\u0026gt;Time, Val.X); Curve-\u0026gt;FloatCurves[0].SetKeyInterpMode(Key, ERichCurveInterpMode::RCIM_Cubic); Key = Curve-\u0026gt;FloatCurves[1].UpdateOrAddKey(Point-\u0026gt;Time, Val.Y); Curve-\u0026gt;FloatCurves[1].SetKeyInterpMode(Key, ERichCurveInterpMode::RCIM_Cubic); Key = Curve-\u0026gt;FloatCurves[2].UpdateOrAddKey(Point-\u0026gt;Time, Val.Z); Curve-\u0026gt;FloatCurves[2].SetKeyInterpMode(Key, ERichCurveInterpMode::RCIM_Cubic); } /** 获取 Curve 所有值的时间区间 */ Curve-\u0026gt;GetTimeRange(Time, MaxTime); /** 画出整个 Curve 曲线 */ while (Time \u0026lt; MaxTime) { FVector Start = LineDrawer-\u0026gt;Points-\u0026gt;GetVectorValue(Time) + ActorLocation; FVector End = LineDrawer-\u0026gt;Points-\u0026gt;GetVectorValue(Time + 0.1) + ActorLocation; PDI-\u0026gt;DrawLine(Start, End, FLinearColor::Red, SDPG_World, 2.0f); Time += 0.1; } } } 上述代码参杂了太多的我个人项目所需的代码逻辑，其实核心代码就是简简单单的一行\nPDI-\u0026gt;DrawLine(Start, End, FLinearColor::Red, SDPG_World, 2.0f); 我们看下 DrawLine() 的声明 1 2 3 4 5 6 7 8 9 virtual void DrawLine( const FVector\u0026amp; Start, const FVector\u0026amp; End, const FLinearColor\u0026amp; Color, uint8 DepthPriorityGroup, float Thickness = 0.0f, float DepthBias = 0.0f, bool bScreenSpace = false ) = 0; 很清晰了，就是这些参数。\n其实原本是准备用 MeshComponent 来画线的，顺便学习下怎么自定义一个 Mesh，但属实能力不够只能先用 Visualizer 凑合凑合，有时间搞定了 Mesh 到时候再发一篇。\n参考链接: https://sondreutheim.com/post/ue4_component_visualizers 参考项目: https://github.com/sutheim/UE4-ComponentVisualizer-Example\n","date":"2021-08-24T00:00:00Z","image":"https://cdn.jsdelivr.net/gh/Lazarus-glhf/ImageStorage@main/Blog/67d0602f4859a873876856fc8f306e7a.png","permalink":"https://example.com/p/ue-componentvisualizer/","title":"UE ComponentVisualizer"}]